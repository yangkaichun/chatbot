<!DOCTYPE html>
<html lang="zh-TW">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>æ›è™Ÿç§‘åˆ¥æ¨è–¦ v5 (API)</title> <style>
        /* CSS remains the same as v3/v4 */
        :root {
            --user-msg-bg: #dcf8c6;
            --bot-msg-bg: #fff;
            --input-bg: #fff;
            --bg-color: #f0f0f0;
            --text-color: #333;
            --button-bg: #007bff;
            --button-active-bg: #0056b3;
            --voice-bg: #5bc0de;
            --voice-recording-bg: #d9534f;
            --border-color: #ccc;
            --chat-height: 85vh;
            --input-height: 15vh;
        }
        html, body { height: 100%; margin: 0; padding: 0; overflow: hidden; }
        body { font-family: -apple-system, BlinkMacSystemFont, "Segoe UI", Roboto, "Helvetica Neue", Arial, sans-serif; display: flex; flex-direction: column; background-color: var(--bg-color); color: var(--text-color); font-size: 16px; }
        #chat-container { height: var(--chat-height); overflow-y: auto; padding: 10px; display: flex; flex-direction: column; gap: 12px; box-sizing: border-box; }
        .message { padding: 10px 15px; border-radius: 18px; max-width: 85%; word-wrap: break-word; line-height: 1.4; box-shadow: 0 1px 2px rgba(0,0,0,0.1); }
        .user-message { background-color: var(--user-msg-bg); align-self: flex-end; border-bottom-right-radius: 5px; margin-left: auto; }
        .bot-message { background-color: var(--bot-msg-bg); align-self: flex-start; border: 1px solid #eee; border-bottom-left-radius: 5px; margin-right: auto; }
        #input-area { height: var(--input-height); min-height: 50px; max-height: var(--input-height); display: flex; align-items: center; padding: 8px 10px; border-top: 1px solid var(--border-color); background-color: var(--input-bg); box-sizing: border-box; flex-shrink: 0; }
        #user-input { flex-grow: 1; padding: 10px 15px; border: 1px solid var(--border-color); border-radius: 20px; margin-right: 8px; font-size: inherit; line-height: 1.4; min-height: 24px; max-height: calc(var(--input-height) - 30px); resize: none; overflow-y: auto; box-sizing: border-box; font-family: inherit; }
        button { padding: 0; border: none; border-radius: 50%; cursor: pointer; background-color: transparent; color: var(--button-bg); font-size: 24px; width: 40px; height: 40px; display: flex; justify-content: center; align-items: center; flex-shrink: 0; transition: background-color 0.2s ease, color 0.2s ease, opacity 0.2s ease; }
        #send-button { margin-left: 5px; color: var(--button-bg); }
        #voice-button { color: var(--voice-bg); }
        #voice-button.recording { color: white; background-color: var(--voice-recording-bg); }
        button:active { opacity: 0.7; }
        #chat-container::-webkit-scrollbar { width: 0; background: transparent; }
        #chat-container { scrollbar-width: none; -ms-overflow-style: none; }
    </style>
</head>
<body>

    <div id="chat-container">
        <div class="message bot-message">æ‚¨å¥½ï¼è«‹é»æ“Š ğŸ¤ é–‹å§‹èªªè©±ï¼Œæˆ–ç›´æ¥è¼¸å…¥æ–‡å­—æè¿°æ‚¨çš„ç—‡ç‹€ã€‚(é¦–æ¬¡ä½¿ç”¨å¯èƒ½éœ€å…è¨±éº¥å…‹é¢¨æ¬Šé™)</div>
    </div>

    <div id="input-area">
        <textarea id="user-input" placeholder="è«‹è¼¸å…¥ç—‡ç‹€..." rows="1"></textarea> <button id="voice-button" title="èªéŸ³è¼¸å…¥">ğŸ¤</button>
        <button id="send-button" title="ç™¼é€" style="display: none;">â¤</button>
    </div>

    <script>
        const chatContainer = document.getElementById('chat-container');
        const userInput = document.getElementById('user-input');
        const sendButton = document.getElementById('send-button');
        const voiceButton = document.getElementById('voice-button');

        // NOTE: No local 'knowledgeBase' needed anymore for recommendation logic

        // --- Speech Recognition Setup (Same as v3/v4 - requires careful testing with async handleUserInput) ---
        const SpeechRecognition = window.SpeechRecognition || window.webkitSpeechRecognition;
        let recognition;
        let isRecording = false;
        let finalTranscript = ''; // Used to prevent duplicate addUserMessage from voice

        if (SpeechRecognition) {
            try {
                recognition = new SpeechRecognition();
                recognition.continuous = false;
                recognition.lang = 'zh-TW';
                recognition.interimResults = true;
                recognition.maxAlternatives = 1;

                recognition.onresult = (event) => {
                    let interimTranscript = '';
                    let currentFinalTranscript = ''; // Use local var for this event cycle
                    for (let i = event.resultIndex; i < event.results.length; ++i) {
                        if (event.results[i].isFinal) {
                            currentFinalTranscript += event.results[i][0].transcript;
                        } else {
                            interimTranscript += event.results[i][0].transcript;
                        }
                    }
                    userInput.value = currentFinalTranscript || interimTranscript; // Show interim or final
                    adjustTextareaHeight();

                    // IMPORTANT: Process ONLY when final transcript segment is received for THIS speech event
                    if (currentFinalTranscript) {
                        finalTranscript = currentFinalTranscript.trim(); // Store globally for check in handleUserInput
                        if (finalTranscript) {
                            handleUserInput(finalTranscript); // Call async function
                        } else {
                             console.log("Final transcript was empty after trimming.");
                             userInput.placeholder = "è«‹é»æ“Š ğŸ¤ æˆ–è¼¸å…¥æ–‡å­—...";
                        }
                    }
                };

                recognition.onerror = (event) => {
                    console.error('Speech Recognition Error:', event.error, event.message);
                    let errorMessage = "èªéŸ³è¾¨è­˜æ™‚ç™¼ç”ŸæœªçŸ¥éŒ¯èª¤ã€‚";
                    switch (event.error) { /* Cases from v3/v4 */
                       case 'no-speech': errorMessage = "æˆ‘æ²’æœ‰è½åˆ°è²éŸ³ï¼Œè«‹æ‚¨é è¿‘éº¥å…‹é¢¨å†è©¦ä¸€æ¬¡ã€‚"; break;
                       case 'audio-capture': errorMessage = "ç„¡æ³•å–å¾—éº¥å…‹é¢¨éŸ³è¨Šï¼Œè«‹æª¢æŸ¥ç³»çµ±è¨­å®šæˆ–ç€è¦½å™¨æ˜¯å¦å·²æˆæ¬Šã€‚"; break;
                       case 'not-allowed': errorMessage = "æ‚¨å°šæœªå…è¨±æˆ–å·²æ‹’çµ•ä½¿ç”¨éº¥å…‹é¢¨ï¼Œè«‹è‡³ç€è¦½å™¨è¨­å®šä¸­é–‹å•Ÿæ¬Šé™å¾Œå†è©¦ã€‚"; break;
                       case 'network': errorMessage = "ç¶²è·¯é€£ç·šéŒ¯èª¤ï¼ŒèªéŸ³è¾¨è­˜éœ€è¦ç©©å®šçš„ç¶²è·¯é€£ç·šã€‚"; break;
                       case 'aborted': if (!isRecording) return; errorMessage = "èªéŸ³è¾¨è­˜è¢«ä¸­æ­¢ã€‚"; break;
                       case 'service-not-allowed': errorMessage = "ç€è¦½å™¨æˆ–ä½œæ¥­ç³»çµ±ç¦æ­¢ä½¿ç”¨èªéŸ³è¾¨è­˜æœå‹™ï¼Œè«‹æª¢æŸ¥ç›¸é—œè¨­å®šã€‚"; break;
                       case 'bad-grammar': errorMessage = "èªéŸ³è¾¨è­˜èªæ³•è¨­å®šéŒ¯èª¤ã€‚"; break;
                       default: errorMessage = `ç™¼ç”Ÿæœªé æœŸçš„éŒ¯èª¤ (${event.error})ï¼Œè«‹ç¨å¾Œå†è©¦ã€‚`;
                    }
                    if(errorMessage) addBotMessage(errorMessage); // Use modified addBotMessage
                    userInput.placeholder = "è«‹é»æ“Š ğŸ¤ æˆ–è¼¸å…¥æ–‡å­—...";
                    if(isRecording) toggleRecordingState();
                };

                recognition.onstart = () => { userInput.placeholder = "æ­£åœ¨è†è½..."; };
                recognition.onend = () => { if(isRecording) toggleRecordingState(); userInput.placeholder = "è«‹é»æ“Š ğŸ¤ æˆ–è¼¸å…¥æ–‡å­—..."; };

            } catch (e) { /* Error handling from v3/v4 */
                console.error("ç„¡æ³•åˆå§‹åŒ– SpeechRecognition:", e);
                addBotMessage("åˆå§‹åŒ–èªéŸ³è¾¨è­˜å¤±æ•—ï¼Œæ‚¨çš„ç€è¦½å™¨å¯èƒ½ä¸æ”¯æ´æ­¤åŠŸèƒ½ã€‚"); // Use modified addBotMessage
                voiceButton.disabled = true; voiceButton.style.color = '#ccc'; voiceButton.title = "èªéŸ³è¾¨è­˜åˆå§‹åŒ–å¤±æ•—"; userInput.placeholder = "è«‹ä½¿ç”¨æ–‡å­—è¼¸å…¥";
            }
        } else { /* Fallback from v3/v4 */
             voiceButton.disabled = true; voiceButton.style.color = '#ccc'; voiceButton.title = "ç€è¦½å™¨ä¸æ”¯æ´èªéŸ³è¼¸å…¥"; addBotMessage("æŠ±æ­‰ï¼Œæ‚¨çš„ç€è¦½å™¨ä¸æ”¯æ´èªéŸ³è¼¸å…¥åŠŸèƒ½ã€‚è«‹æ”¹ç”¨æ–‡å­—è¼¸å…¥ã€‚"); // Use modified addBotMessage
             userInput.placeholder = "è«‹è¼¸å…¥æ–‡å­—...";
        }

        // --- UI Helpers (Same as v3/v4) ---
        function toggleRecordingState() {
            isRecording = !isRecording;
            voiceButton.classList.toggle('recording', isRecording);
            voiceButton.innerHTML = isRecording ? 'â—¼' : 'ğŸ¤';
            voiceButton.title = isRecording ? "åœæ­¢éŒ„éŸ³" : "èªéŸ³è¼¸å…¥";
        }
        function adjustTextareaHeight() {
            userInput.style.height = 'auto';
            let scrollHeight = userInput.scrollHeight;
            const computedStyle = window.getComputedStyle(userInput);
            const maxHeight = parseInt(computedStyle.maxHeight, 10);
            const effectiveMaxHeight = isNaN(maxHeight) ? scrollHeight : maxHeight;
            if (scrollHeight > effectiveMaxHeight) {
                userInput.style.height = effectiveMaxHeight + 'px';
                userInput.style.overflowY = 'auto';
            } else {
                const minHeight = parseInt(computedStyle.minHeight, 10) || 24;
                userInput.style.height = Math.max(scrollHeight, minHeight) + 'px';
                userInput.style.overflowY = 'hidden';
            }
        }

        // --- Event Listeners (Same as v3/v4, but call async handleUserInput) ---
        voiceButton.addEventListener('click', () => {
            if (!recognition || voiceButton.disabled) return;
            if (isRecording) { if (recognition) recognition.stop(); }
            else {
                try {
                    finalTranscript = ''; // Clear flag before starting
                    userInput.value = ''; adjustTextareaHeight();
                    recognition.start(); toggleRecordingState();
                } catch (err) { /* Error handling from v3/v4 */
                     console.error("ç„¡æ³•å•Ÿå‹•èªéŸ³è¾¨è­˜ (catch):", err);
                     if (err.name === 'InvalidStateError') { addBotMessage("èªéŸ³è¾¨è­˜å·²åœ¨é€²è¡Œä¸­ã€‚"); if (!isRecording) toggleRecordingState(); } // Use modified addBotMessage
                     else { addBotMessage(`å•Ÿå‹•èªéŸ³è¾¨è­˜å¤±æ•— (${err.name})ï¼Œè«‹æª¢æŸ¥æ¬Šé™æˆ–ç¨å¾Œå†è©¦ã€‚`); if(isRecording) toggleRecordingState(); } // Use modified addBotMessage
                }
            }
        });
        sendButton.addEventListener('click', () => { const text = userInput.value.trim(); if (text) handleUserInput(text); }); // Calls async function
        userInput.addEventListener('input', () => { const hasText = userInput.value.trim().length > 0; sendButton.style.display = hasText ? 'flex' : 'none'; adjustTextareaHeight(); });
        userInput.addEventListener('keypress', (e) => { if (e.key === 'Enter' && !e.shiftKey) { e.preventDefault(); const text = userInput.value.trim(); if (text) handleUserInput(text); } }); // Calls async function


        // --- Core Functions ---
        // Original addMessage, kept for reference/internal use by addBotMessage/addUserMessage
         function _addMessageElement(text, sender) {
            const messageDiv = document.createElement('div');
            messageDiv.classList.add('message', sender === 'user' ? 'user-message' : 'bot-message');
            messageDiv.textContent = text;
            chatContainer.appendChild(messageDiv);
            chatContainer.scrollTo({ top: chatContainer.scrollHeight, behavior: 'smooth' });
            return messageDiv; // Return element
        }

        function addUserMessage(text) {
             _addMessageElement(text, 'user');
        }

        // Modified addBotMessage: Adds delay AND returns element
        function addBotMessage(text) {
            // Add slight delay for bot messages to feel more natural
            // Return the element after timeout - complicates removing "Thinking..."
            // Let's return the element immediately and add delay within the function if needed elsewhere
             const messageElement = _addMessageElement(text, 'bot');
             return messageElement; // Return the created element
        }

        // --- !!! NEW handleUserInput Function (Calls Backend API) !!! ---
        async function handleUserInput(text) { // Add async keyword
            if (!text) return; // Ignore empty input

            // Add user message only if it's truly new content (e.g., not a duplicate from voice)
            const lastUserMessage = chatContainer.querySelector('.user-message:last-child');
             // Check against finalTranscript flag set by voice recognition event
             // Also check if it's different from the last displayed message text
            if (text !== finalTranscript || !lastUserMessage || lastUserMessage.textContent !== text) {
                 addUserMessage(text);
            }
             finalTranscript = ''; // Clear voice flag after potentially adding message

            userInput.value = '';
            adjustTextareaHeight();
            sendButton.style.display = 'none';

            // --- Call Backend API ---
            // =======================================================================
            // !!! IMPORTANT: Replace with the ACTUAL URL of your deployed backend !!!
            // =======================================================================
            const BACKEND_URL = 'https://your-deployed-backend-service-url.xxxx.run.app/api/recommend'; // <--- CHANGE THIS URL !!!
            // =======================================================================

            let thinkingMsg = null; // Variable to hold the "thinking" message element
            try {
                // Add a temporary "Thinking..." message for the bot
                thinkingMsg = addBotMessage("AI æ­£åœ¨æ€è€ƒä¸­...");

                const response = await fetch(BACKEND_URL, {
                    method: 'POST',
                    headers: {
                        'Content-Type': 'application/json',
                        // Add other headers if needed by your backend/CORS policy
                    },
                    body: JSON.stringify({ symptoms: text }), // Send symptoms in request body
                });

                // Remove the "Thinking..." message AFTER getting a response (success or fail)
                if(thinkingMsg && thinkingMsg.parentNode) {
                    thinkingMsg.remove();
                }

                if (!response.ok) {
                    let errorData = { error: `è«‹æ±‚å¤±æ•— (${response.status})`};
                    try {
                        // Try to parse backend error message if available
                        const errJson = await response.json();
                         if(errJson && errJson.error) errorData.error = errJson.error;
                    } catch (e) { /* Ignore if response is not JSON */ }
                    console.error("Backend request failed:", response.status, errorData);
                    addBotMessage(`æŠ±æ­‰ï¼Œèˆ‡ AI ä¼ºæœå™¨æºé€šæ™‚ç™¼ç”ŸéŒ¯èª¤ã€‚${errorData.error}`);
                    return; // Stop processing on error
                }

                const data = await response.json();

                // Display the recommendation received from the backend
                if (data.recommendation) {
                     addBotMessage(data.recommendation); // Display the response crafted by the backend
                } else {
                     // Handle cases where backend might return success but no recommendation content
                     console.warn("Backend returned success but no recommendation content:", data);
                     addBotMessage("æŠ±æ­‰ï¼ŒAI æœªèƒ½æä¾›æœ‰æ•ˆçš„å»ºè­°ã€‚");
                }

            } catch (error) {
                 // Remove the "Thinking..." message on network/fetch error too
                 if(thinkingMsg && thinkingMsg.parentNode) {
                    thinkingMsg.remove();
                 }

                console.error('Error calling backend API:', error);
                addBotMessage("æŠ±æ­‰ï¼Œç„¡æ³•é€£æ¥åˆ° AI ä¼ºæœå™¨ã€‚è«‹æª¢æŸ¥ç¶²è·¯é€£ç·šæˆ–ç¨å¾Œå†è©¦ã€‚");
            }
        }

        // Initial setup
        userInput.placeholder = "è«‹é»æ“Š ğŸ¤ æˆ–è¼¸å…¥æ–‡å­—...";
        adjustTextareaHeight();

    </script>

</body>
</html>
