<!DOCTYPE html>
<html lang="zh-TW">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>æ›è™Ÿç§‘åˆ¥æ¨è–¦ v4</title> <style>
        /* CSS remains the same as v3 */
        :root {
            --user-msg-bg: #dcf8c6;
            --bot-msg-bg: #fff;
            --input-bg: #fff;
            --bg-color: #f0f0f0;
            --text-color: #333;
            --button-bg: #007bff;
            --button-active-bg: #0056b3;
            --voice-bg: #5bc0de;
            --voice-recording-bg: #d9534f;
            --border-color: #ccc;
            --chat-height: 85vh;
            --input-height: 15vh;
        }
        html, body { height: 100%; margin: 0; padding: 0; overflow: hidden; }
        body { font-family: -apple-system, BlinkMacSystemFont, "Segoe UI", Roboto, "Helvetica Neue", Arial, sans-serif; display: flex; flex-direction: column; background-color: var(--bg-color); color: var(--text-color); font-size: 16px; }
        #chat-container { height: var(--chat-height); overflow-y: auto; padding: 10px; display: flex; flex-direction: column; gap: 12px; box-sizing: border-box; }
        .message { padding: 10px 15px; border-radius: 18px; max-width: 85%; word-wrap: break-word; line-height: 1.4; box-shadow: 0 1px 2px rgba(0,0,0,0.1); }
        .user-message { background-color: var(--user-msg-bg); align-self: flex-end; border-bottom-right-radius: 5px; margin-left: auto; }
        .bot-message { background-color: var(--bot-msg-bg); align-self: flex-start; border: 1px solid #eee; border-bottom-left-radius: 5px; margin-right: auto; }
        #input-area { height: var(--input-height); min-height: 50px; max-height: var(--input-height); display: flex; align-items: center; padding: 8px 10px; border-top: 1px solid var(--border-color); background-color: var(--input-bg); box-sizing: border-box; flex-shrink: 0; }
        #user-input { flex-grow: 1; padding: 10px 15px; border: 1px solid var(--border-color); border-radius: 20px; margin-right: 8px; font-size: inherit; line-height: 1.4; min-height: 24px; max-height: calc(var(--input-height) - 30px); resize: none; overflow-y: auto; box-sizing: border-box; font-family: inherit; }
        button { padding: 0; border: none; border-radius: 50%; cursor: pointer; background-color: transparent; color: var(--button-bg); font-size: 24px; width: 40px; height: 40px; display: flex; justify-content: center; align-items: center; flex-shrink: 0; transition: background-color 0.2s ease, color 0.2s ease, opacity 0.2s ease; }
        #send-button { margin-left: 5px; color: var(--button-bg); }
        #voice-button { color: var(--voice-bg); }
        #voice-button.recording { color: white; background-color: var(--voice-recording-bg); }
        button:active { opacity: 0.7; }
        #chat-container::-webkit-scrollbar { width: 0; background: transparent; }
        #chat-container { scrollbar-width: none; -ms-overflow-style: none; }
    </style>
</head>
<body>

    <div id="chat-container">
        <div class="message bot-message">æ‚¨å¥½ï¼è«‹é»æ“Š ğŸ¤ é–‹å§‹èªªè©±ï¼Œæˆ–ç›´æ¥è¼¸å…¥æ–‡å­—æè¿°æ‚¨çš„ç—‡ç‹€ã€‚(é¦–æ¬¡ä½¿ç”¨å¯èƒ½éœ€å…è¨±éº¥å…‹é¢¨æ¬Šé™)</div>
    </div>

    <div id="input-area">
        <textarea id="user-input" placeholder="æ­£åœ¨è†è½..." rows="1"></textarea>
        <button id="voice-button" title="èªéŸ³è¼¸å…¥">ğŸ¤</button>
        <button id="send-button" title="ç™¼é€" style="display: none;">â¤</button>
    </div>

    <script>
        const chatContainer = document.getElementById('chat-container');
        const userInput = document.getElementById('user-input');
        const sendButton = document.getElementById('send-button');
        const voiceButton = document.getElementById('voice-button');

        // --- Knowledge Base (Explicit PDF/Gemini sources) ---
        const knowledgeBase = [
             // --- From PDF (Source: PDF) ---
            { keywords: ["è†½", "ç—›", "å¤–ç§‘", "é–‹åˆ€", "è‚è†½"], department: "ä¸€èˆ¬å¤–ç§‘", source: "PDF" }, // Added "è‚è†½" from text
            { keywords: ["å¾Œé ­", "ç²‰ç˜¤", "é–‹åˆ€"], department: "ä¸€èˆ¬å¤–ç§‘", source: "PDF" },
            { keywords: ["è…³", "å‚·å£", "è…«", "ç´…", "éµ", "ç´®åˆ°", "åˆºåˆ°", "è…³èƒŒ"], department: "ä¸€èˆ¬å¤–ç§‘", source: "PDF" }, // Added "è…³èƒŒ"
            { keywords: ["è…³", "å‚·å£", "æ„ŸæŸ“", "åŒ–è†¿", "è…³èƒŒ"], department: "æ„ŸæŸ“ç§‘", source: "PDF" }, // Added "è…³èƒŒ"
            { keywords: ["èƒ¸éƒ¨", "ç•°ç‰©", "ç¡¬å¡Š", "ä¹³æˆ¿"], department: "ä¹³æˆ¿å¤–ç§‘", source: "PDF" }, // Assuming "èƒ¸éƒ¨æœ‰ç•°ç‰©" points to ä¹³æˆ¿å¤–ç§‘ based on context
            { keywords: ["åˆ†æ³Œç‰©", "å¢åŠ ", "æ€§äº¤", "å‡ºè¡€", "éª¨ç›†", "ç—›", "HPV", "æ·‹ç—…"], department: "å©¦ç”¢éƒ¨ å©¦ç§‘", source: "PDF" }, // Added keywords from description
            { keywords: ["å­å®®", "è„«å‚", "éª¨ç›†", "å£“è¿«æ„Ÿ", "ä¸‹è…¹è„¹", "æ’å°¿å›°é›£", "æ’ä¾¿å›°é›£"], department: "å©¦ç”¢éƒ¨ å©¦ç§‘", source: "PDF" }, // Added keywords
            { keywords: ["éª¨ç›†è…”", "ç™¼ç‚", "åˆ†æ³Œç‰©", "ç•°å¸¸", "ç™¼ç‡’", "ä¸‹è…¹ç—›", "PID"], department: "å©¦ç”¢éƒ¨ å©¦ç§‘", source: "PDF" }, // Added keywords
            { keywords: ["æµç”¢", "æ‡·å­•", "å‡ºè¡€", "è…¹ç—›", "çµ„ç¹”æ’å‡º"], department: "å©¦ç”¢éƒ¨ ç”¢ç§‘", source: "PDF" },
            { keywords: ["å­å®®å¤–å­•", "ç•°ä½å¦Šå¨ ", "æ‡·å­•", "ä¸‹è…¹ç—›", "å‡ºè¡€", "æ˜å¥", "ä½è¡€å£“"], department: "å©¦ç”¢éƒ¨ ç”¢ç§‘", source: "PDF" }, // Added keywords
            { keywords: ["æ‡·å­•", "æ™šæœŸ", "å‡ºè¡€", "åŠ‡çƒˆ", "è…¹ç—›", "èƒå‹•", "æ¸›å°‘", "èƒç›¤", "å‰é›¢"], department: "å©¦ç”¢éƒ¨ ç”¢ç§‘", source: "PDF" }, // Added keywords

             // --- From Gemini (Source: Gemini, Constrained by PDF Depts) ---
            { keywords: ["å‰²", "ç—”ç˜¡"], department: "ä¸€èˆ¬å¤–ç§‘", source: "Gemini" },
            { keywords: ["ç–æ°£", "è„«è…¸"], department: "ä¸€èˆ¬å¤–ç§‘", source: "Gemini" },
            { keywords: ["ç”²ç‹€è…º", "è…«å¤§", "çµç¯€"], department: "ä¸€èˆ¬å¤–ç§‘", source: "Gemini" },
            { keywords: ["çš®è†š", "è…«å¡Š", "è„‚è‚ªç˜¤", "åˆ‡é™¤"], department: "ä¸€èˆ¬å¤–ç§‘", source: "Gemini" },
            { keywords: ["é—Œå°¾ç‚", "ç›²è…¸ç‚", "å³ä¸‹è…¹", "ç—›"], department: "ä¸€èˆ¬å¤–ç§‘", source: "Gemini" },
            { keywords: ["ç™¼ç‡’", "ä¸æ˜åŸå› ", "æŒçºŒ", "ç•å¯’"], department: "æ„ŸæŸ“ç§‘", source: "Gemini" },
            { keywords: ["èœ‚çª©æ€§çµ„ç¹”ç‚"], department: "æ„ŸæŸ“ç§‘", source: "Gemini" },
            { keywords: ["è‚ºç‚", "åè¦†", "æ²»ç™‚æ•ˆæœä¸ä½³"], department: "æ„ŸæŸ“ç§‘", source: "Gemini" }, // If complex
            { keywords: ["ä¹³é ­", "åˆ†æ³Œç‰©", "å‡¹é™·", "çš®è†šæ©˜çš®"], department: "ä¹³æˆ¿å¤–ç§‘", source: "Gemini" },
            { keywords: ["ä¹³æˆ¿", "ç–¼ç—›", "é€±æœŸæ€§"], department: "ä¹³æˆ¿å¤–ç§‘", source: "Gemini" },
            { keywords: ["æœˆç¶“", "ä¸è¦å‰‡", "ç•°å¸¸", "ç¶“ç—›", "åš´é‡"], department: "å©¦ç”¢éƒ¨ å©¦ç§‘", source: "Gemini" },
            { keywords: ["æ›´å¹´æœŸ", "ç—‡ç‹€", "ç›œæ±—", "ç†±æ½®ç´…"], department: "å©¦ç”¢éƒ¨ å©¦ç§‘", source: "Gemini" },
            { keywords: ["é™°é“", "æ”ç™¢", "ç•°å‘³"], department: "å©¦ç”¢éƒ¨ å©¦ç§‘", source: "Gemini" },
            { keywords: ["é¿å­•", "è«®è©¢", "æ–¹å¼"], department: "å©¦ç”¢éƒ¨ å©¦ç§‘", source: "Gemini" },
            { keywords: ["æ‡·å­•", "ç”¢æª¢", "æª¢æŸ¥"], department: "å©¦ç”¢éƒ¨ ç”¢ç§‘", source: "Gemini" },
            { keywords: ["ç”Ÿç”¢", "è«®è©¢", "æ¥ç”Ÿ"], department: "å©¦ç”¢éƒ¨ ç”¢ç§‘", source: "Gemini" },
            { keywords: ["ç”¢å¾Œ", "å›è¨º", "å¾©åŸ"], department: "å©¦ç”¢éƒ¨ ç”¢ç§‘", source: "Gemini" },
            { keywords: ["ä¸å­•", "è«®è©¢", "æª¢æŸ¥"], department: "å©¦ç”¢éƒ¨ å©¦ç§‘", source: "Gemini" }
        ];

        // --- Speech Recognition Setup (Same as v3) ---
        const SpeechRecognition = window.SpeechRecognition || window.webkitSpeechRecognition;
        let recognition;
        let isRecording = false;
        let finalTranscript = '';

        if (SpeechRecognition) {
            try {
                recognition = new SpeechRecognition();
                recognition.continuous = false;
                recognition.lang = 'zh-TW';
                recognition.interimResults = true;
                recognition.maxAlternatives = 1;

                recognition.onresult = (event) => {
                    let interimTranscript = '';
                    finalTranscript = '';
                    for (let i = event.resultIndex; i < event.results.length; ++i) {
                        if (event.results[i].isFinal) {
                            finalTranscript += event.results[i][0].transcript;
                        } else {
                            interimTranscript += event.results[i][0].transcript;
                        }
                    }
                    userInput.value = finalTranscript || interimTranscript;
                    adjustTextareaHeight();
                    if (finalTranscript) {
                        const processedTranscript = finalTranscript.trim();
                        if (processedTranscript) {
                            handleUserInput(processedTranscript);
                        } else {
                             console.log("Final transcript was empty after trimming.");
                             userInput.placeholder = "è«‹é»æ“Š ğŸ¤ æˆ–è¼¸å…¥æ–‡å­—...";
                        }
                        finalTranscript = ''; // Clear memory
                    }
                };

                recognition.onerror = (event) => {
                    console.error('Speech Recognition Error:', event.error, event.message);
                    let errorMessage = "èªéŸ³è¾¨è­˜æ™‚ç™¼ç”ŸæœªçŸ¥éŒ¯èª¤ã€‚";
                    switch (event.error) { /* Cases from v3 */
                       case 'no-speech': errorMessage = "æˆ‘æ²’æœ‰è½åˆ°è²éŸ³ï¼Œè«‹æ‚¨é è¿‘éº¥å…‹é¢¨å†è©¦ä¸€æ¬¡ã€‚"; break;
                       case 'audio-capture': errorMessage = "ç„¡æ³•å–å¾—éº¥å…‹é¢¨éŸ³è¨Šï¼Œè«‹æª¢æŸ¥ç³»çµ±è¨­å®šæˆ–ç€è¦½å™¨æ˜¯å¦å·²æˆæ¬Šã€‚"; break;
                       case 'not-allowed': errorMessage = "æ‚¨å°šæœªå…è¨±æˆ–å·²æ‹’çµ•ä½¿ç”¨éº¥å…‹é¢¨ï¼Œè«‹è‡³ç€è¦½å™¨è¨­å®šä¸­é–‹å•Ÿæ¬Šé™å¾Œå†è©¦ã€‚"; break;
                       case 'network': errorMessage = "ç¶²è·¯é€£ç·šéŒ¯èª¤ï¼ŒèªéŸ³è¾¨è­˜éœ€è¦ç©©å®šçš„ç¶²è·¯é€£ç·šã€‚"; break;
                       case 'aborted': if (!isRecording) return; errorMessage = "èªéŸ³è¾¨è­˜è¢«ä¸­æ­¢ã€‚"; break; // Ignore if stopped manually
                       case 'service-not-allowed': errorMessage = "ç€è¦½å™¨æˆ–ä½œæ¥­ç³»çµ±ç¦æ­¢ä½¿ç”¨èªéŸ³è¾¨è­˜æœå‹™ï¼Œè«‹æª¢æŸ¥ç›¸é—œè¨­å®šã€‚"; break;
                       case 'bad-grammar': errorMessage = "èªéŸ³è¾¨è­˜èªæ³•è¨­å®šéŒ¯èª¤ã€‚"; break;
                       default: errorMessage = `ç™¼ç”Ÿæœªé æœŸçš„éŒ¯èª¤ (${event.error})ï¼Œè«‹ç¨å¾Œå†è©¦ã€‚`;
                    }
                    if(errorMessage) addBotMessage(errorMessage);
                    userInput.placeholder = "è«‹é»æ“Š ğŸ¤ æˆ–è¼¸å…¥æ–‡å­—...";
                    if(isRecording) toggleRecordingState();
                };

                recognition.onstart = () => { userInput.placeholder = "æ­£åœ¨è†è½..."; };
                recognition.onend = () => { if(isRecording) toggleRecordingState(); userInput.placeholder = "è«‹é»æ“Š ğŸ¤ æˆ–è¼¸å…¥æ–‡å­—..."; };

            } catch (e) { /* Error handling from v3 */
                console.error("ç„¡æ³•åˆå§‹åŒ– SpeechRecognition:", e);
                addBotMessage("åˆå§‹åŒ–èªéŸ³è¾¨è­˜å¤±æ•—ï¼Œæ‚¨çš„ç€è¦½å™¨å¯èƒ½ä¸æ”¯æ´æ­¤åŠŸèƒ½ã€‚");
                voiceButton.disabled = true; voiceButton.style.color = '#ccc'; voiceButton.title = "èªéŸ³è¾¨è­˜åˆå§‹åŒ–å¤±æ•—"; userInput.placeholder = "è«‹ä½¿ç”¨æ–‡å­—è¼¸å…¥";
            }
        } else { /* Fallback from v3 */
             voiceButton.disabled = true; voiceButton.style.color = '#ccc'; voiceButton.title = "ç€è¦½å™¨ä¸æ”¯æ´èªéŸ³è¼¸å…¥"; addBotMessage("æŠ±æ­‰ï¼Œæ‚¨çš„ç€è¦½å™¨ä¸æ”¯æ´èªéŸ³è¼¸å…¥åŠŸèƒ½ã€‚è«‹æ”¹ç”¨æ–‡å­—è¼¸å…¥ã€‚"); userInput.placeholder = "è«‹è¼¸å…¥æ–‡å­—...";
        }

        // --- UI Helpers (Same as v3) ---
        function toggleRecordingState() {
            isRecording = !isRecording;
            voiceButton.classList.toggle('recording', isRecording);
            voiceButton.innerHTML = isRecording ? 'â—¼' : 'ğŸ¤';
            voiceButton.title = isRecording ? "åœæ­¢éŒ„éŸ³" : "èªéŸ³è¼¸å…¥";
        }
        function adjustTextareaHeight() {
            userInput.style.height = 'auto';
            let scrollHeight = userInput.scrollHeight;
            const computedStyle = window.getComputedStyle(userInput);
            const maxHeight = parseInt(computedStyle.maxHeight, 10);
            const effectiveMaxHeight = isNaN(maxHeight) ? scrollHeight : maxHeight;
            if (scrollHeight > effectiveMaxHeight) {
                userInput.style.height = effectiveMaxHeight + 'px';
                userInput.style.overflowY = 'auto';
            } else {
                const minHeight = parseInt(computedStyle.minHeight, 10) || 24;
                userInput.style.height = Math.max(scrollHeight, minHeight) + 'px';
                userInput.style.overflowY = 'hidden';
            }
        }

        // --- Event Listeners (Same as v3) ---
        voiceButton.addEventListener('click', () => {
            if (!recognition || voiceButton.disabled) return;
            if (isRecording) { if (recognition) recognition.stop(); }
            else {
                try {
                    finalTranscript = ''; userInput.value = ''; adjustTextareaHeight();
                    recognition.start(); toggleRecordingState();
                } catch (err) { /* Error handling from v3 */
                     console.error("ç„¡æ³•å•Ÿå‹•èªéŸ³è¾¨è­˜ (catch):", err);
                     if (err.name === 'InvalidStateError') { addBotMessage("èªéŸ³è¾¨è­˜å·²åœ¨é€²è¡Œä¸­ã€‚"); if (!isRecording) toggleRecordingState(); }
                     else { addBotMessage(`å•Ÿå‹•èªéŸ³è¾¨è­˜å¤±æ•— (${err.name})ï¼Œè«‹æª¢æŸ¥æ¬Šé™æˆ–ç¨å¾Œå†è©¦ã€‚`); if(isRecording) toggleRecordingState(); }
                }
            }
        });
        sendButton.addEventListener('click', () => { const text = userInput.value.trim(); if (text) handleUserInput(text); });
        userInput.addEventListener('input', () => { const hasText = userInput.value.trim().length > 0; sendButton.style.display = hasText ? 'flex' : 'none'; adjustTextareaHeight(); });
        userInput.addEventListener('keypress', (e) => { if (e.key === 'Enter' && !e.shiftKey) { e.preventDefault(); const text = userInput.value.trim(); if (text) handleUserInput(text); } });

        // --- Core Functions ---
        function addMessage(text, sender) {
            const messageDiv = document.createElement('div');
            messageDiv.classList.add('message', sender === 'user' ? 'user-message' : 'bot-message');
            messageDiv.textContent = text;
            chatContainer.appendChild(messageDiv);
            chatContainer.scrollTo({ top: chatContainer.scrollHeight, behavior: 'smooth' });
        }
        function addUserMessage(text) { addMessage(text, 'user'); }
        function addBotMessage(text) { setTimeout(() => { addMessage(text, 'bot'); }, 150); }

        // --- !!! MODIFIED handleUserInput Function !!! ---
        function handleUserInput(text) {
            if (!text) return; // Ignore empty input

            const lastUserMessage = chatContainer.querySelector('.user-message:last-child');
            if (!lastUserMessage || lastUserMessage.textContent !== text) {
                 addUserMessage(text);
            }

            userInput.value = '';
            adjustTextareaHeight();
            sendButton.style.display = 'none';

            // --- Prioritized Matching Logic ---
            let bestPdfMatch = null;
            let maxPdfScore = 0;
            let bestGeminiMatch = null;
            let maxGeminiScore = 0;

            const lowerCaseText = text.toLowerCase();

            // Iterate through KB to find best matches for each source type
            knowledgeBase.forEach(item => {
                let currentScore = 0;
                item.keywords.forEach(keyword => {
                    if (lowerCaseText.includes(keyword.toLowerCase())) {
                        currentScore += keyword.length; // Weight by keyword length
                    }
                });

                if (currentScore > 0) {
                    if (item.source === 'PDF') {
                        // Update best PDF match
                        if (currentScore > maxPdfScore) {
                            maxPdfScore = currentScore;
                            bestPdfMatch = item;
                        }
                        // Basic tie-breaking: prefer shorter keyword list if scores are equal
                        else if (currentScore === maxPdfScore && bestPdfMatch && item.keywords.length < bestPdfMatch.keywords.length) {
                             bestPdfMatch = item;
                        }
                    } else if (item.source === 'Gemini') {
                        // Update best Gemini match
                        if (currentScore > maxGeminiScore) {
                            maxGeminiScore = currentScore;
                            bestGeminiMatch = item;
                        }
                         // Basic tie-breaking: prefer shorter keyword list if scores are equal
                        else if (currentScore === maxGeminiScore && bestGeminiMatch && item.keywords.length < bestGeminiMatch.keywords.length) {
                            bestGeminiMatch = item;
                        }
                    }
                }
            });

            // --- Decision Making based on Priority ---
            let finalRecommendation = null;
            let sourceUsed = null;

            // Priority 1: Use PDF match if found
            if (bestPdfMatch && maxPdfScore > 0) {
                finalRecommendation = bestPdfMatch;
                sourceUsed = 'ä¾†æº: PDF æ–‡ä»¶';
            }
            // Priority 2: Use Gemini match if NO PDF match found
            else if (bestGeminiMatch && maxGeminiScore > 0) {
                finalRecommendation = bestGeminiMatch;
                sourceUsed = 'ä¾†æº: AI çŸ¥è­˜åº«';
            }

            // --- Provide Response ---
            setTimeout(() => {
                if (finalRecommendation) {
                    addBotMessage(`æ ¹æ“šæ‚¨çš„æè¿°ã€Œ${text}ã€ï¼Œ${sourceUsed}å»ºè­°æ‚¨å¯ä»¥è€ƒæ…®æ›ã€Œ${finalRecommendation.department}ã€ã€‚æé†’æ‚¨ï¼Œé€™åƒ…ç‚ºåˆæ­¥å»ºè­°ï¼Œå¯¦éš›æƒ…æ³è«‹è«®è©¢å°ˆæ¥­é†«å¸«ã€‚`);
                } else {
                    addBotMessage("æŠ±æ­‰ï¼Œæˆ‘æš«æ™‚ç„¡æ³•å¾æ‚¨çš„æè¿°ä¸­åˆ¤æ–·é©åˆçš„ç§‘åˆ¥ã€‚æ‚¨å¯ä»¥è©¦è‘—æè¿°æ›´å…·é«”çš„ç—‡ç‹€ã€éƒ¨ä½æˆ–æ„Ÿå—ï¼Œä¾‹å¦‚ï¼šã€Œå³ä¸‹è…¹åŠ‡ç—›å·²ç¶“åŠå¤©äº†ã€æˆ–ã€Œå–‰åš¨ç—›è€Œä¸”æœ‰é»ç™¼ç‡’ã€ã€‚");
                }
            }, 300 + Math.random() * 300);
        }

        // Initial setup
        userInput.placeholder = "è«‹é»æ“Š ğŸ¤ æˆ–è¼¸å…¥æ–‡å­—...";
        adjustTextareaHeight();

    </script>

</body>
</html>
